## 가. JavaScript의 객체지향 특징

1. #### 클래스는 없고 프로토타입만 있다

   - '인스턴스화 및 인스턴스'라는 개념은 존재하나 클래스가 없고, '프로토타입(모형)' 개념만 존재

2. #### 가장 간단한 클래스 정의하기

   ```javascript
   var Member = function() {}; //자바스크립트의 Member 클래스
   var mem = new Member(); // new 연산자로 인스턴스화
   ```

   - JavaScript에서는 함수(`Function ` 객체)에 클래스의 역할을 부여한다.

   - 애로우 함수에서는 생성자를 정의할 수 없다(ES2015)

     ```javascript
     let Member = () => { ... 생성자의 내용 ...};
     let m = new Member(); // Error : Member is not a constructor
     ```

     (ES2015) 환경에서는 순수하게 class 명령을 이용해야 한다.

3. #### 생성자로 초기화하기

   ```javascript
   var Member = function(firstName, lastName) {
   	this.firstName = firstName;
   	this.lastName = lastName;
   	this.getName = function() {
   		return this.lastName + ' '+ this.firstName;
   	}
   };
   var mem = new Member('철수', '강');
   console.log(mem.getName()); //결과 : 강 철수
   ```

   - `this`키워드는 생성자에 의해 생성되는 인스턴스를 나타냄
   - 함수 객체로서의 값이 프로퍼티의 메소드로 간주됨.

4. #### 동적으로 메소드 추가하기

   - 메소드를 나중에 정의하는 방식

     ```javascript
     var Member = function(firstName, lastName) {
     	this.firstName = firstName;
     	this.lastName = lastName;
     }
     
     var mem = new Member('철수', '강');
     mem.getName = function() {
     	return this.lastName + ' ' + this.firstName;
     }//생성된 인스턴스에 대해 메소드가 추가되고 있음.
     console.log(mem.getName());// 결과 : 강 철수
     ```

   - 인스턴스에 대해서 직접 멤버(프로퍼티 or 메소드)를 추가하는 방식

     ```javascript
     var Member = function(firstName, lastName) {
     	this.firstName = firstName;
     	this.lastName = lastName;
     }
     var mem = new Member('철수', '강');
     
     mem.getName = function() {
     	return this.lastName + ' ' + this.firstName;
     }
     console.log(mem.getName()); //결과 : 강 철수
     
     var mem2 = new Member('영희', '이');
     console.log(mem2.getName()); // error : mem2.getName is not a function
     ```

5. 문맥에 따라 내용이 변하는 변수 - this 키워드

   - this 키워드가 참조하는 곳

     - 톱 레벨(함수의 바깥) - 글로벌 객체

     - 함수 - 글로벌 객체(`strict`모드에서는 `undefined`)

     - `call`/`apply` 메소드 - 인수로 지정된 객체

       ```javascript
       func.call(that [,arg1 [,arg2 [,...]]])
       func.apply(that [,args])
       /*
       func : 함수 객체
       that : 함수 안에서 this 키워드가 가리키는 것
       			 참고로 인수 that에 null을 건넬경우, 암묵적으로 글로벌 객체가 건네진 것으로 간주.
       arg1, arg2, ... : 함수에 건넬 인수
       args : 함수에 건넬 인수(배열)
       */
       ```

       ```javascript
       //call method 예시. apply 메소드의 경우도 동일함.
       var data = 'Global data';
       var obj1 = { data: 'obj1 data' };
       var obj2 = { data: 'obj2 data' };
       
       function hoge() {
       	console.log(this.data);
       }
       
       hoge.call(null); //결과 : Global data
       hoge.call(obj1); //결과 : obj1 data
       hoge.call(obj2); //결과 : obj2 data
       ```

       ```javascript
       //배열과 비슷하지만 배열이 아닌 객체를 배열로 변환하기
       function hoge() {
       	//arguments 객체를 this로 해서 Array.slice 객체를 호출하시오.
       	var args = Array.prototype.slice.call(arguments);
       	console.log(args.join('/'));
       }
       hoge('Angular', 'React', 'Backbone'); // 결과 : Angular/React/Backbone
       ```

     - 이벤트 리스너 - 이벤트의 발생처

     - 생성자 - 생성한 인스턴스

     - 메소드 - 호출원의 객체(= 리시버 객체)

6. 생성자의 강제적인 호출

   ```javascript
   var Member = function(firstName, lastName) {
   	this.firstName = firstName;
   	this.lastName = lastName;
   };
   
   var m = Member('인식', '정');
   console.log(m); //결과 : undefined
   console.log(firstName); //결과 : 인식
   console.log(m.firstName); // 결과 : 에러(Cannot read property 'firstName' of undefined)
   ```

   이 경우 `Member`객체는 생성되지 않고, 대신 글로벌 변수로 `firstName`/`lastName`이 생성되어 버린다(`this`가 글로벌 객체를 나타내고 있기 때문)

   따라서

   ```javascript
   var Member = function(firstName, lastName) {
   	if(!(this instanceof Member)) {//여기서 this는 Member 객체가 아니라 글로벌 객체. 
   		return new Member(firstName, lastName);//따라서 아닌 경우 new 연산자로 호출.
   	}
   	this.firstName = firstName;
   	...중략...
   };
   ```



## 나. 생성자의 문제점과 프로토타입

0. 생성자에 의한 메소드 추가 → 메소드의 수에 비례하여 '쓸데없이' 메모리를 소비한다.

1. 메모리는 프로토타입으로 선언한다 - `prototype`프로퍼티

   - 객체를 인스턴스화 했을 경우, 인스턴스는 베이스가 되는 객체에 속하는 `prototype`객체에 대해서 암묵적인 참조를 갖게 된다.

     ```javascript
     var Member = function(firstName, lastName) {
     	this.firstName = firstName;
     	this.lastName = lastName;
     }
     
     Member.prototype.getName = function() {
     	return this.lastName + ' ' + this.firstName;
     
     var mem = new Member('인식' + '정');
     console.log(mem.getName()); // 결과 : 정 인식
     // prototype 객체에 추가된 getName 메소드가 Member 클래스의 인스턴스(변수 mem)에서도 올바르게 참조됨.
     ```

2. 프로토타입 객체를 사용한 메소드 정의의 두가지 이점

   - 메모리의 사용량을 절감할 수 있다.

     - JavaScript에서는 객체의 멤버가 호출되었을 때 다음의 흐름으로 멤버를 취득

       - 인스턴스 측에 요구된 멤버가 존재하지 않는지 확인

       - 존재하지 않는 경우에는 암묵적인 참조를 통해 프로토타입 객체를 검색

         -> 생성자 경유로 메소드 정의시 발생하는 메모리 낭비 문제 회피.

